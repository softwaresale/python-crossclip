
# crossclip -- cross platform clipboard API
# Copyright (C) 2019  Charlie Sale

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# GtkBackend.py -- Gtk clipboard backend class



class GtkBackend(BaseBackend):
    """
    Backend for the GTK clipboard. This class abstracts/wraps most of the
    functionality of Gtk.Clipboard

    TODO: add methods doc string
    """
    @staticmethod
    def pixbuf_to_pillow(pixbuf):
        """ Converts a GdkPixbuf.Pixbuf to PIL.Image

        This converts a Gdk Pixbuf to a PIl image. PIL images
        are a little more universial
        """
        data = pixbuf.get_pixels()
        width = pixbuf.props.width
        height = pixbuf.props.height
        stride = pixbuf.props.rowstride
        mode = 'RGB'
        if pixbuf.props.has_alpha is True:
            mode = 'RGBA'

        return PilImage.frombytes(mode, (width, height), data, 'raw', mode, stride)

    @staticmethod
    def image_to_pixbuf(image):
        """ Convert PIL.Image to GdkPixbuf.Pixbuf

        This converts a PIL Image to Gdk Pixbuf
        """
        data = image.tobytes()
        w, h = image.size
        data = GLib.Bytes.new(data)
        pix = GdkPixbuf.Pixbuf.new_from_bytes(data, GdkPixbuf.Colorspace.RGB, False, 8, w, h, w * 3)

    def __init__(self, display=None, gq_max_size=0):
        """ Constructs a new instance.

        This takes the default clipboard from whatever display is specified.
        If no display is specified, the default is gotten

        Parameters
        ----------
        display : Gdk.Display, optional
            Display to get keyboard from

        max_size : int, optional
            Size of the get queue. If not specified, size is unlimited
        """
        # Gets default clipboard for default screen
        self.clipboard = GtkClipboard.get_default(GdkDisplay.get_default())

    def set_text(self, text):
        """ Adds text to the clipboard

        Simply copy function. All text is copied automatically

        Paramters
        ---------
        text : str
            Text to copy to clipboard
        """
        self.clipboard.set_text(text, -1)

    def set_image(self, pilim):
        """ Adds a PIL image object to the clipboard

        This takes a PIL.Image object and places it on the
        clipboard

        Parameters
        ----------
        pilim : PIL.Image
            Image object to add
        """
        # Create byte array
        arr = array.array('B', pilim.tostring())
        height, width = pilim.size
        return Pixbuf.new_from_data(arr, Colorspace.RGB, True, 8, width, height, width * 4, None, None)

    def get_text(self):
        """ Synchronously get text from clipboard

        This function blocks until it gets text
        """
        return self.clipboard.wait_for_text()

    def get_image(self, imgtype='Pil'):
        """ Synchronously get image from clipboard

        This blocks until it gets an image from the clipboard. It's format can
        be specified by the user.

        Parameters
        ----------
        imgtype : str
            Type for image. Options are 'Pil' for PIL.Image,
            'Gdk' for GdkPixbuf.Pixbuf, or 'Raw', for raw data
        """
        pixbuf = self.clipboard.wait_for_image()

        if imgtype is 'Gdk':
            return pixbuf
        elif imgtype is 'Raw':
            return pixbuf.get_pixels() # TODO: This may be faulty
        elif imgtype is 'Pil':
            return GtkClipboardBackend.pixbuf_to_pillow(pixbuf)

    def get_next(self, block=True):
        """ Gets next queued item

        Gets the next queued item from the wait queue. This function is
        synchronous, but the queue that it operates on is asynchronous. This
        means that its contents may update inconsistently. The return data is
        a directory. Its properties are 'type', which is either 'text' or
        'image', and 'item', which is the actual item.

        Parameters
        ----------
        block : bool, optional
            If get from queue should block. Default is True
        """
        next_item = self.getqueue.get(block)
        return next_item

    def kill_polling(self):
        self.poll_halt.set()
